import { and, eq } from 'drizzle-orm';
import { getClient } from '@/lib/database/postgres/client';
import { DatabaseError } from '@/lib/errors/DatabaseError';
import type { PostgresDBClient } from '@/types';
import { aiSchemaCache } from '../../schemas/ai-schema-cache';
import { translateDatabase } from '@/lib/database/i18n';

// Could live in shared types; kept local for now
export type AiSchemaFeature =
    | 'column_tagging'
    | 'table_overview'
    | 'explain_summary'
    | string;

export type AiSchemaCacheRecord = typeof aiSchemaCache.$inferSelect;

export type AiSchemaCacheKey = {
    teamId: string;
    connectionId: string;
    catalog: string;
    feature: AiSchemaFeature;
    schemaHash: string;
    model: string;
    promptVersion: number;
};

export type AiSchemaCacheUpsert = AiSchemaCacheKey & {
    dbType?: string | null;
    databaseName?: string | null;
    tableName?: string | null;
    payload: unknown;
};

export interface AiSchemaCacheRepository {
    init(): Promise<void>;
    find(key: AiSchemaCacheKey): Promise<AiSchemaCacheRecord | null>;
    upsert(entry: AiSchemaCacheUpsert): Promise<void>;
    deleteByConnection(teamId: string, connectionId: string): Promise<void>;
}

export class PostgresAiSchemaCacheRepository implements AiSchemaCacheRepository {
    private db!: PostgresDBClient;

    async init(): Promise<void> {
        try {
            this.db = (await getClient()) as PostgresDBClient;
        } catch (error) {
            console.error(translateDatabase('Database.Logs.AiSchemaCacheInitFailed'), error);
            throw new DatabaseError(translateDatabase('Database.Errors.InitFailed'), 500);
        }
    }

    async find(key: AiSchemaCacheKey): Promise<AiSchemaCacheRecord | null> {
        const [row] = await this.db
            .select()
            .from(aiSchemaCache)
            .where(
                and(
                    eq(aiSchemaCache.teamId, key.teamId),
                    eq(aiSchemaCache.connectionId, key.connectionId),
                    eq(aiSchemaCache.catalog, key.catalog),
                    eq(aiSchemaCache.feature, key.feature),
                    eq(aiSchemaCache.schemaHash, key.schemaHash),
                    eq(aiSchemaCache.model, key.model),
                    eq(aiSchemaCache.promptVersion, key.promptVersion),
                ),
            )
            .limit(1);

        return (row as AiSchemaCacheRecord | undefined) ?? null;
    }

    async upsert(entry: AiSchemaCacheUpsert): Promise<void> {
        const now = new Date().toISOString();

        // Key point 1: enforce $inferInsert typing
        const insertPayload: typeof aiSchemaCache.$inferInsert = {
            // id can be omitted; generated by $defaultFn(newEntityId)
            teamId: entry.teamId,
            connectionId: entry.connectionId,
            catalog: entry.catalog || 'default',

            feature: entry.feature,
            dbType: entry.dbType ?? null,
            databaseName: entry.databaseName ?? null,
            tableName: entry.tableName ?? null,

            schemaHash: entry.schemaHash,
            model: entry.model,
            promptVersion: entry.promptVersion,

            payload: entry.payload as any,

            // If table has defaultNow + onUpdateFn, these can be omitted
            createdAt: now,
            updatedAt: now,
        };

        // Key point 2: updatePayload uses Partial<typeof ...>
        const updatePayload: Partial<typeof aiSchemaCache.$inferInsert> = {
            dbType: insertPayload.dbType,
            databaseName: insertPayload.databaseName,
            tableName: insertPayload.tableName,
            payload: insertPayload.payload,
            updatedAt: now,
        };

        await this.db
            .insert(aiSchemaCache)
            .values(insertPayload)
            .onConflictDoUpdate({
                target: [
                    aiSchemaCache.teamId,
                    aiSchemaCache.connectionId,
                    aiSchemaCache.catalog,
                    aiSchemaCache.feature,
                    aiSchemaCache.schemaHash,
                    aiSchemaCache.model,
                    aiSchemaCache.promptVersion,
                ],
                set: updatePayload,
            });
    }

    async deleteByConnection(teamId: string, connectionId: string): Promise<void> {
        await this.db
            .delete(aiSchemaCache)
            .where(
                and(
                    eq(aiSchemaCache.teamId, teamId),
                    eq(aiSchemaCache.connectionId, connectionId),
                ),
            );
    }
}
